A binary tree is a type of tree data structure where a node can have either 0, 1 or 2 children.

Binary Tree Representation

1. Array Representation


Array Representation
----------------------

Formulae to Find the address of Children Nodes
-----------------------------------------------

Left Child = Address of Parent Node * 2 + 1
Right Child = Address of Parenet Node * 2 + 2


Formulae to Find the address of Parent Node
-------------------------------------------

Parent of Left Child = Address of Child Node / 2 
Parent of Right Child = Address of Child Node / 2 - 1


Formulae to Determine the Size of an array of level N Tree.
-----------------------------------------------------------

2**(N+1) - 1

Length of an array of Level 2 Tree : 2**(2+1)-1	: 7
Length of an array of Level 3 Tree : 2**(3+1)-1 : 15


Types of Binary Tree:
---------------------

1. Strict Binary Tree

Strictly binary trees are binary trees where every node either has two children or is a leaf (has no children).

2. Complete Binary Tree
Binary trees are complete binary trees where every leaf is on the same "maximum" level.

3. Almost Complete Binary Tree
Binary trees are almost complete binary trees if all leaf nodes are either on level d or on level d-1. 


Tree Traversal
--------------

1. In Order Traversal		(Left->Parent->Right)
2. Pre Order Traversal      (Parent->Left->Right)
3. Post Order Traversal 	(Left->Right->Parent)


Binary Tree Operations
----------------------

1. Insertion
2. Deletion
3. Searching
4. Traversal






Binary Tree Program
-------------------

class BinaryTree
{
	String []arr;
	int height;
	int size;

	public BinaryTree(int height){
		this.height=height;
		size=Math.pow(2,(height+1)+1);
		arr=new int[size];
	}

	public InOrder(int index){
		if(arr[index]==-1 && index>size) 			//-1 is null
		{ 
			return;
		} 			

		InOrder(index*2+1);			//Traverse the Left Child
		System.out.println()		//Print The Element
		InOrder(index*2+2);			//Traverse the Right Child
	}


	public Search(int index,String parent){
	
		if(arr[index]==-1 && index>size) 			//-1 is null
		{ 
			return;
		} 			

		return InOrder(index*2+1);			
		if(arr[index].equals(parent)){
				return index;
		}
		return InOrder(index*2+2);			
	}


	public PreOrder(int index){
		if(arr[index]==-1 && index>size) 			//-1 is null
		{ 
			return;
		} 			

		System.out.println()		//Print The Element
		InOrder(index*2+1);			//Traverse the Left Child
		InOrder(index*2+2);			//Traverse the Right Child	
	}

	public PreOrder(int index){
		if(arr[index]==-1 && index>size) 			//-1 is null
		{ 
			return;
		} 			

		InOrder(index*2+1);			//Traverse the Left Child
		InOrder(index*2+2);			//Traverse the Right Child	
		System.out.println()		//Print The Element
	}


	public Insert(int value)
	{
		Scanner input = new Scanner(System.in);

		print("\n\n");
		System.out.println("Choose Position of the Value [0 : Root, 1 : Left, 2 : Right");
		int pos=input.nextInt();
		input.nextLine();

		if(pos==0){
			arr[0]=value;
		}
		else{
			System.out.println("Enter Value of the Parent Node : ");
			String parent = input.nextLine();
			int index=Search(0,parent);
			arr[index]=value;
		}
	}
}


obj.Insert("A");
obj.Insert("B");

obj.PreOrder(0);
